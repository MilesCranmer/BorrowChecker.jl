<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · BorrowChecker.jl</title><meta name="title" content="Home · BorrowChecker.jl"/><meta property="og:title" content="Home · BorrowChecker.jl"/><meta property="twitter:title" content="Home · BorrowChecker.jl"/><meta name="description" content="Documentation for BorrowChecker.jl."/><meta property="og:description" content="Documentation for BorrowChecker.jl."/><meta property="twitter:description" content="Documentation for BorrowChecker.jl."/><meta property="og:url" content="https://ai.damtp.cam.ac.uk/borrowcheckerjl/"/><meta property="twitter:url" content="https://ai.damtp.cam.ac.uk/borrowcheckerjl/"/><link rel="canonical" href="https://ai.damtp.cam.ac.uk/borrowcheckerjl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>BorrowChecker.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Automatic-Checking:-BorrowChecker.@auto"><span>Automatic Checking: <code>BorrowChecker.@auto</code></span></a></li><li><a class="tocitem" href="#Manual-Overlay-(explicit-ownership/borrow-macros)"><span>Manual Overlay (explicit ownership/borrow macros)</span></a></li></ul></li><li><a class="tocitem" href="auto/"><code>@auto</code></a></li><li><a class="tocitem" href="api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mcranmer/BorrowChecker.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MilesCranmer/BorrowChecker.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><img src="https://github.com/user-attachments/assets/b68b4d0e-7bec-4876-a39d-5edf3191a8d9" alt/></p><h1 id="BorrowChecker.jl"><a class="docs-heading-anchor" href="#BorrowChecker.jl">BorrowChecker.jl</a><a id="BorrowChecker.jl-1"></a><a class="docs-heading-anchor-permalink" href="#BorrowChecker.jl" title="Permalink"></a></h1><p><a href="https://astroautomata.com/BorrowChecker.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://github.com/MilesCranmer/BorrowChecker.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/MilesCranmer/BorrowChecker.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status"/></a> <a href="https://coveralls.io/github/MilesCranmer/BorrowChecker.jl?branch=main"><img src="https://coveralls.io/repos/github/MilesCranmer/BorrowChecker.jl/badge.svg?branch=main" alt="Coverage"/></a></p><p>This is an experimental package for emulating a runtime borrow checker in Julia, using a macro layer over regular code. This is built to mimic Rust&#39;s ownership, lifetime, and borrowing semantics. This tool is mainly to be used in development and testing to flag memory safety issues, and help you design safer code.</p><p>BorrowChecker.jl currently has two alternative layers:</p><ol><li><strong>Automatic checking (<code>BorrowChecker.@auto</code>)</strong><ul><li>Drop-in for existing Julia code: wrap a function and BorrowChecker will run a best-effort borrow check when that method specialization executes.</li><li>It does not change program behavior (except for throwing when it finds a violation).</li></ul></li><li><strong>Manual overlay (explicit ownership/borrow macros like <code>@own</code>, <code>@ref</code>, <code>@take!</code>, …)</strong><ul><li>More explicit and safer, but much more effort and invasive.</li><li>More feature complete.</li></ul></li></ol><p>In Julia, when you write <code>x = [1, 2, 3]</code>, the actual <em>object</em> exists completely independently of the variable, and you can refer to it from as many variables as you want without issue:</p><pre><code class="language-julia hljs">x = [1, 2, 3]
y = x
println(length(x))
# 3</code></pre><p>Once there are no more references to the object, the &quot;garbage collector&quot; will work to free the memory.</p><p>Rust is much different. For example, the equivalent code is <strong>invalid</strong> in Rust</p><pre><code class="language-rust hljs">let x = vec![1, 2, 3];
let y = x;
println!(&quot;{}&quot;, x.len());
// error[E0382]: borrow of moved value: `x`</code></pre><p>Rust refuses to compile this code. Why? Because in Rust, objects (<code>vec![1, 2, 3]</code>) are <em>owned</em> by variables. When you write <code>let y = x</code>, the ownership of <code>vec![1, 2, 3]</code> is <em>moved</em> to <code>y</code>. Now <code>x</code> is no longer allowed to access it.</p><p>To fix this, we would either write</p><pre><code class="language-rust hljs">let y = x.clone();
// OR
let y = &amp;x;</code></pre><p>to either create a copy of the vector, or <em>borrow</em> <code>x</code> using the <code>&amp;</code> operator to create a reference. You can create as many references as you want, but there can only be one original object.</p><p>This &quot;ownership&quot; paradigm can help improve safety of code. Especially in complex, multithreaded codebases, it is easy to shoot yourself in the foot and modify objects which are &quot;owned&quot; (editable) by something else. Rust&#39;s ownership and lifetime model makes it so that you can <em>prove</em> memory safety of code! Standard thread races are literally impossible. (Assuming you are not using <code>unsafe { ... }</code> to disable safety features, or the borrow checker itself has a bug, etc.)</p><p>In BorrowChecker.jl, we demonstrate an implementation of some of these ideas. The aim is to build a development layer that can help prevent a few classes of memory safety issues, without affecting runtime behavior of code.</p><h2 id="Automatic-Checking:-BorrowChecker.@auto"><a class="docs-heading-anchor" href="#Automatic-Checking:-BorrowChecker.@auto">Automatic Checking: <code>BorrowChecker.@auto</code></a><a id="Automatic-Checking:-BorrowChecker.@auto-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Checking:-BorrowChecker.@auto" title="Permalink"></a></h2><p><code>BorrowChecker.@auto</code> automatically instruments a function by analyzing the compiler IR and runs a best-effort borrow check at runtime. This requires Julia ≥ 1.12.</p><blockquote><p>[!WARNING] This macro is highly experimental and compiler-dependent. There are likely bugs and false positives. It is intended for development and testing, and does not guarantee memory safety.</p></blockquote><h3 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h3><p><code>@auto</code> supports a few options that are compiled into a <code>BorrowChecker.Auto.Config</code>:</p><ul><li><code>scope</code> (default <code>:function</code>): whether to recursively borrow-check callees (<code>:none</code>, <code>:function</code>, <code>:module</code>, <code>:user</code>, <code>:all</code>).</li><li><code>max_summary_depth</code> (default <code>12</code>): recursion depth limit for effect summarization when effects cannot be directly resolved.</li><li><code>optimize_until</code> (default varies): which compiler pass to stop at when fetching IR (<code>Base.code_ircode_by_type</code>).</li></ul><p><code>scope</code> meanings:</p><ul><li><code>:none</code>: disable <code>@auto</code> entirely.</li><li><code>:function</code>: check only the annotated method.</li><li><code>:module</code>: recursively check callees defined in the module where <code>@auto</code> is used.</li><li><code>:user</code>: recursively check callees, but ignore <code>Core</code> and <code>Base</code> (including their submodules).</li><li><code>:all</code>: recursively check callees across all modules (very aggressive).</li></ul><p>The <code>@auto</code> checked-cache is keyed by specialization <em>and these options</em>, so checking a function once under <code>scope=:function</code> will not incorrectly skip a later recursive check under <code>scope=:module</code> / <code>:all</code>.</p><p><code>@auto</code> is meant to be a <em>drop-in tripwire</em> for existing code:</p><ul><li><strong>Aliasing violations</strong>: mutating a value while another live binding may observe that mutation.</li><li><strong>Escapes / &quot;moves&quot;</strong>: storing a mutable value somewhere that outlives the current scope (e.g. a global cache / a field / a container), then continuing to reference it locally.</li></ul><p>This analyzes the compiler’s IR, so it can catch patterns that are &quot;hidden&quot; by lowering (keyword calls, closure captures, views, etc.). It is intentionally <strong>best-effort</strong>: when it cannot determine what a call does, it will be conservative (and may throw false positives). For code where you want a stronger, explicit model, use the manual overlay macros below.</p><h3 id="How-it-works"><a class="docs-heading-anchor" href="#How-it-works">How it works</a><a id="How-it-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-it-works" title="Permalink"></a></h3><p>When you write:</p><pre><code class="language-julia hljs">BorrowChecker.@auto function f(args...)
    # ...
end</code></pre><p>the macro rewrites the function so that:</p><ol><li><strong>On entry</strong>, it runs a borrow check for the <em>current method specialization</em> (e.g. <code>f(::Vector{Int})</code>), and caches the result (so future calls are faster).</li><li>The checker asks Julia for the function&#39;s <strong>typed compiler IR</strong> (the lowered form the compiler optimizes).</li><li>It walks that IR and tracks two key things:<ul><li>Which bindings may refer to the <strong>same mutable object</strong> (aliasing).</li><li>Which operations <strong>write</strong> to a tracked object or cause it to <strong>escape</strong> (be treated like a move).</li></ul></li><li>When it sees an operation that would be illegal under Rust-like rules (e.g. &quot;write while aliased&quot;, or &quot;use after escape&quot;), it throws a <code>BorrowCheckError</code> with a source-level-ish diagnostic.</li></ol><h3 id="Aliasing-Detection"><a class="docs-heading-anchor" href="#Aliasing-Detection">Aliasing Detection</a><a id="Aliasing-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Aliasing-Detection" title="Permalink"></a></h3><p>BorrowChecker.jl&#39;s <code>@auto</code> macro can detect when values are modified through aliased bindings, and throw an error:</p><pre><code class="language-julia hljs">julia&gt; import BorrowChecker

julia&gt; BorrowChecker.@auto function f()
           x = [1, 2, 3]
           y = x
           push!(x, 4)
           return y
       end
f (generic function with 1 method)

julia&gt; f()  # errors</code></pre><p>This will generate a helpful error pointing out the location of the borrow check violation, and the statement that violated the rule:</p><pre><code class="nohighlight hljs">ERROR: BorrowCheckError for specialization Tuple{typeof(f)}

  method: f() @ Main REPL[7]:1

  [1] stmt#7: cannot perform write: value is aliased by another live binding      at REPL[7]:4
        2         x = [1, 2, 3]
        3         y = x
      &gt; 4         push!(x, 4)
        5         return y
        6     end

      stmt: Main.push!(%5, 4)
</code></pre><p>To fix it, simply copy the value, which will avoid the error:</p><pre><code class="language-julia hljs">julia&gt; BorrowChecker.@auto function f()
           x = [1, 2, 3]
           y = copy(x)
           push!(x, 4)
           return y
       end
f (generic function with 1 method)

julia&gt; f()
3-element Vector{Int64}:
 1
 2
 3</code></pre><h3 id="Escape-Detection"><a class="docs-heading-anchor" href="#Escape-Detection">Escape Detection</a><a id="Escape-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Escape-Detection" title="Permalink"></a></h3><p>Much like Rust&#39;s ownership model, BorrowChecker.jl&#39;s <code>@auto</code> macro attempts to infer when values escape their scope (moved/consumed) and throw an error if they are used afterwards.</p><pre><code class="language-julia hljs">julia&gt; const CACHE = Dict()
Dict{Any, Any}()

julia&gt; foo(x) = (CACHE[x] = 1; nothing)
foo (generic function with 1 method)

julia&gt; BorrowChecker.@auto function bar()
           x = [1, 2]
           foo(x)
           return x
       end
bar (generic function with 1 method)

julia&gt; bar()  # errors</code></pre><p>This generates the following error:</p><pre><code class="nohighlight hljs">ERROR: BorrowCheckError for specialization Tuple{typeof(bar)}

  method: bar() @ Main REPL[13]:1

  [1] stmt#6: value escapes/consumed by unknown call; it (or an alias) is used later      at REPL[13]:3
        1     BorrowChecker.@auto function bar()
        2         x = [1, 2]
      &gt; 3         foo(x)
        4         return x
        5     end

      stmt: Main.foo(%5)</code></pre><p>Why is this an error? Because <code>x</code> was stored as a key in the cache, but is <em>mutable externally</em>. Furthermore, it is returned by <code>bar</code>! This is a violation of borrowing rules. Once the value gets stored in the cache, its ownership is <em>transferred</em> to the cache, and is no longer accessible by <code>bar</code>. So this example is illegal.</p><p>How can we fix it? We have two options. The first is we can copy the value before storing it:</p><pre><code class="language-julia hljs">julia&gt; BorrowChecker.@auto function bar()
           x = [1, 2]
           foo(copy(x))
           return x
       end
bar (generic function with 1 method)

julia&gt; bar()  # ok</code></pre><p>We no longer have access to the object created by <code>copy(x)</code>, so the borrow check passes. Alternatively, we can use immutable objects, which are safe to pass around:</p><pre><code class="language-julia hljs">julia&gt; BorrowChecker.@auto function bar()
           x = (1, 2)
           foo(x)
           return x
       end
bar (generic function with 1 method)

julia&gt; bar()  # ok</code></pre><h3 id="More-@auto-examples"><a class="docs-heading-anchor" href="#More-@auto-examples">More <code>@auto</code> examples</a><a id="More-@auto-examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-@auto-examples" title="Permalink"></a></h3><p>&lt;details&gt; &lt;summary&gt;&lt;code&gt;@auto&lt;/code&gt; analyzes the entire callstack&lt;/summary&gt;</p><p>BorrowChecker doesn&#39;t rely on naming conventions, such as the presence of <code>!</code> in the function name. It tries to infer effects from IR:</p><pre><code class="language-julia hljs">julia&gt; h(x) = (push!(x, 1); nothing)  # no &quot;!&quot; in the name
h (generic function with 1 method)

julia&gt; BorrowChecker.@auto function demo()
           x = [1, 2, 3]
           y = x
           h(x)
           return y
       end
demo (generic function with 1 method)

julia&gt; demo()  # errors</code></pre><p>&lt;/details&gt;</p><p>&lt;details&gt; &lt;summary&gt;Keyword arguments are handled (the checker sees lowered &lt;code&gt;kwcall&lt;/code&gt; IR)&lt;/summary&gt;</p><p>Keyword calls get lowered into a <code>NamedTuple</code> + <code>Core.kwcall(...)</code>. <code>@auto</code> analyzes the lowered IR, so aliasing via keyword arguments is still visible:</p><pre><code class="language-julia hljs">julia&gt; f(; x, y) = (push!(x, 1); push!(y, 1); x .+ y)
f (generic function with 1 method)

julia&gt; BorrowChecker.@auto function kw_demo()
           x = [1, 2, 3]
           y = x
           return sum(f(; x=x, y=y))
       end
kw_demo (generic function with 1 method)

julia&gt; kw_demo()  # errors</code></pre><p>&lt;/details&gt;</p><p>&lt;details&gt; &lt;summary&gt;Aliasing isn&#39;t only &lt;code&gt;y = x&lt;/code&gt;: views can alias too&lt;/summary&gt;</p><pre><code class="language-julia hljs">julia&gt; BorrowChecker.@auto function view_demo()
           x = [1, 2, 3, 4]
           y = view(x, 1:2)  # aliases x
           push!(x, 9)
           return collect(y)
       end
view_demo (generic function with 1 method)

julia&gt; view_demo()  # errors</code></pre><p>&lt;/details&gt;</p><p>&lt;details&gt; &lt;summary&gt;Closures are analyzed too&lt;/summary&gt;</p><pre><code class="language-julia hljs">julia&gt; BorrowChecker.@auto function closure_demo()
           x = [1, 2, 3]
           y = x
           f = () -&gt; (push!(x, 9); nothing)
           f()
           return y
       end
closure_demo (generic function with 1 method)

julia&gt; closure_demo()  # errors</code></pre><p>Read-only captures are typically fine. &lt;/details&gt;</p><h2 id="Manual-Overlay-(explicit-ownership/borrow-macros)"><a class="docs-heading-anchor" href="#Manual-Overlay-(explicit-ownership/borrow-macros)">Manual Overlay (explicit ownership/borrow macros)</a><a id="Manual-Overlay-(explicit-ownership/borrow-macros)-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-Overlay-(explicit-ownership/borrow-macros)" title="Permalink"></a></h2><p>Alternatively, we can use the manual overlay macros to achieve a more explicit effect. This is much more invasive, but might be useful in teaching you how to think about ownership and borrowing.</p><p>The early Rust example, with BorrowChecker.jl, would look like this:</p><pre><code class="language-julia hljs">using BorrowChecker

@own x = [1, 2, 3]
@own y = x
println(length(x))
# ERROR: Cannot use x: value has been moved</code></pre><p>You see, the <code>@own</code> operation has <em>bound</em> the variable <code>x</code> with the object <code>[1, 2, 3]</code>. The second operation then moves the object to <code>y</code>, and flips the <code>.moved</code> flag on <code>x</code> so it can no longer be used by regular operations.</p><p>The equivalent fixes would respectively be:</p><pre><code class="language-julia hljs">@clone y = x
# OR
@lifetime a begin
    @ref ~a y = x
    #= operations on reference =#
end</code></pre><p>Note that BorrowChecker.jl does not prevent you from cheating the system and using <code>y = x</code> (<em>however, the library does try to flag such mistakes by recording symbols used in the macro</em>). To use this library, you will need to <em>buy in</em> to the system to get the most out of it. But the good news is that you can introduce it in a library gradually:  add <code>@own</code>, <code>@move</code>, etc., inside a single function, and call <code>@take!</code> when passing objects to external functions. And for convenience, a variety of standard library functions will automatically forward operations on the underlying objects.</p><h4 id="Example:-Preventing-Thread-Races"><a class="docs-heading-anchor" href="#Example:-Preventing-Thread-Races">Example: Preventing Thread Races</a><a id="Example:-Preventing-Thread-Races-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Preventing-Thread-Races" title="Permalink"></a></h4><p>BorrowChecker.jl helps prevent data races by enforcing borrowing rules.</p><p>Let&#39;s mock up a simple scenario where two threads modify the same array concurrently:</p><pre><code class="language-julia hljs">data = [1, 2, 3]

modify!(x, i) = (sleep(rand()+0.1); push!(x, i))

t1 = Threads.@spawn modify!(data, 4)
t2 = Threads.@spawn modify!(data, 5)

fetch(t1); fetch(t2)</code></pre><p>This has a silent race condition, and the result will be non-deterministic.</p><p>Now, let&#39;s see what happens if we had used BorrowChecker:</p><pre><code class="language-julia hljs">@own :mut data = [1, 2, 3]

t1 = Threads.@spawn @bc modify!(@mut(data), 4)
t2 = Threads.@spawn @bc modify!(@mut(data), 5)</code></pre><p>Now, when you attempt to fetch the tasks, you will get this error:</p><pre><code class="language-text hljs">nested task error: Cannot create mutable reference: `data` is already mutably borrowed</code></pre><p>This is because in BorrowChecker.jl&#39;s ownership model, similar to Rust, an owned object follows strict borrowing rules to prevent data races and ensure safety. (Though, in practice, you should use <code>BorrowChecker.@spawn</code> instead of <code>Threads.@spawn</code>, so that it validates captured variables.)</p><h3 id="Ownership-Rules"><a class="docs-heading-anchor" href="#Ownership-Rules">Ownership Rules</a><a id="Ownership-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Ownership-Rules" title="Permalink"></a></h3><p>At any given time, an object managed by BorrowChecker.jl can only be accessed in one of the following states:</p><ol><li><p><strong>Direct Ownership:</strong></p><ul><li>The object is accessed directly via its owning variable.</li><li>No active references (<code>Borrowed</code> or <code>BorrowedMut</code>) exist.</li><li>In this state, ownership can be transferred (moved) to another variable, after which the original variable becomes inaccessible. The object can also be mutated if it was declared as mutable (<code>@own :mut ...</code>).</li></ul></li><li><p><strong>Immutable Borrows:</strong></p><ul><li>One or more immutable references (<code>Borrowed</code>) to the object exist.</li><li>While any immutable reference is active:<ul><li>The original owning variable <em>cannot</em> be mutated directly.</li><li>Ownership <em>cannot</em> be moved.</li><li>No mutable references (<code>BorrowedMut</code>) can be created.</li></ul></li><li>Multiple immutable references can coexist peacefully. This allows multiple parts of the code to read the data concurrently without interference.</li></ul></li><li><p><strong>A Mutable Borrow:</strong></p><ul><li>Exactly one mutable reference (<code>BorrowedMut</code>) to the object exists.</li><li>While the mutable reference is active:<ul><li>The original owning variable <em>cannot</em> be accessed or mutated directly.</li><li>Ownership <em>cannot</em> be moved.</li><li>No other references (neither immutable <code>Borrowed</code> nor other mutable <code>BorrowedMut</code>) can be created.</li></ul></li><li>The object <em>can</em> be mutated through the single active mutable reference. This ensures exclusive write access, preventing data races.</li></ul></li></ol><p>In essence: You can have many readers (<code>Borrowed</code>) <strong>or</strong> one writer (<code>BorrowedMut</code>), but not both simultaneously. While any borrow is active, the original owner faces restrictions (cannot be moved, cannot be mutated directly if borrowed immutably, cannot be accessed at all if borrowed mutably).</p><h4 id="Sharp-Edges"><a class="docs-heading-anchor" href="#Sharp-Edges">Sharp Edges</a><a id="Sharp-Edges-1"></a><a class="docs-heading-anchor-permalink" href="#Sharp-Edges" title="Permalink"></a></h4><blockquote><p>[!CAUTION] Be especially careful with closure functions that capture variables, as this is an easy way to silently break the borrowing rules. You should always use the <code>@cc</code> macro to wrap closures as a form of validation:</p><pre><code class="language-julia hljs">safe_closure = @cc (x, y) -&gt; x + y</code></pre><p>This will validate that any captured variable is an immutable reference. Similarly, you should generally prefer the <code>BorrowChecker.@spawn</code> macro instead of <code>Threads.@spawn</code> to validate captured variables.</p></blockquote><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><h4 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h4><ul><li><code>@own [:mut] x [= value]</code>: Create a new owned value (mutable if <code>:mut</code> is specified)<ul><li>These are <code>Owned{T}</code> and <code>OwnedMut{T}</code> objects, respectively.</li><li>You can use <code>@own [:mut] x</code> as a shorthand for <code>@own [:mut] x = x</code> to create owned values at the start of a function.</li></ul></li><li><code>@move [:mut] new = old</code>: Transfer ownership from one variable to another (mutable destination if <code>:mut</code> is specified). <em>Note that this is simply a more explicit version of <code>@own</code> for moving values.</em></li><li><code>@clone [:mut] new = old</code>: Create a deep copy of a value without moving the source (mutable destination if <code>:mut</code> is specified).</li><li><code>@take[!] var</code>: Unwrap an owned value. Using <code>@take!</code> will mark the original as moved, while <code>@take</code> will perform a copy.</li><li><code>getproperty</code> and <code>getindex</code> on owned/borrowed values return a <code>LazyAccessor</code> that preserves ownership/lifetime until the raw value is used.<ul><li>For example, for an object <code>x::Owned{T}</code>, the accessor <code>x.a</code> would return <code>LazyAccessor{typeof(x.a), T, Val{:a}, Owned{T}}</code> which has the same reading/writing constraints as the original.</li></ul></li></ul><h4 id="References-and-Lifetimes"><a class="docs-heading-anchor" href="#References-and-Lifetimes">References and Lifetimes</a><a id="References-and-Lifetimes-1"></a><a class="docs-heading-anchor-permalink" href="#References-and-Lifetimes" title="Permalink"></a></h4><ul><li><code>@lifetime lt begin ... end</code>: Create a scope for references whose lifetimes <code>lt</code> are the duration of the block</li><li><code>@ref ~lt [:mut] var = value</code>: Create a reference, for the duration of <code>lt</code>, to owned value <code>value</code> and assign it to <code>var</code> (mutable if <code>:mut</code> is specified)<ul><li>These are <code>Borrowed{T}</code> and <code>BorrowedMut{T}</code> objects, respectively. Use these in the signature of any function you wish to make compatible with references. In the signature you can use <code>@&amp;(T)</code> and <code>@&amp;(:mut, T)</code> to also allow regular <code>T</code>.</li></ul></li><li><code>Mutex(value)</code>: Creates a thread-safe container for <code>value</code>. Mutexes manage lifetimes implicitly during locks and do not need <code>@own</code>.</li><li><code>@ref_into [:mut] var = mutex[]</code>: Create a reference to the value inside a mutex.<ul><li>Use <code>lock(m)</code> to acquire the lock, <code>@ref_into</code> to create a reference to the value inside the mutex, and <code>unlock(m)</code> to release the lock.</li></ul></li><li><code>@bc f(args...; kws...)</code>: This convenience macro automatically creates a lifetime scope for the duration of the function, and sets up borrowing for any owned input arguments.<ul><li>Use <code>@mut(arg)</code> to mark an input as mutable.</li></ul></li><li><code>@&amp; [:mut] T</code>: Alias for <code>Union{T, Borrowed[Mut]{T}}</code> (incl. lazy versions). Use in function signatures to accept <code>T</code> or its borrowed form.</li></ul><h4 id="Validation"><a class="docs-heading-anchor" href="#Validation">Validation</a><a id="Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Validation" title="Permalink"></a></h4><ul><li><code>@cc closure_expr</code>: Verifies that closures only capture immutable references.</li><li><code>BorrowChecker.@spawn [options...] expr</code>: A safety wrapper around <code>Threads.@spawn</code> that applies <code>@cc</code> to the expression (which is internally put inside a closure).</li></ul><h4 id="Loops"><a class="docs-heading-anchor" href="#Loops">Loops</a><a id="Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Loops" title="Permalink"></a></h4><ul><li><code>@own [:mut] for var in iter</code>: Create a loop over an iterable, assigning ownership of each element to <code>var</code>. The original <code>iter</code> is marked as moved.</li><li><code>@ref ~lt [:mut] for var in iter</code>: Create a loop over an owned iterable, generating references to each element, for the duration of <code>lt</code>.</li></ul><h4 id="Disabling-BorrowChecker"><a class="docs-heading-anchor" href="#Disabling-BorrowChecker">Disabling BorrowChecker</a><a id="Disabling-BorrowChecker-1"></a><a class="docs-heading-anchor-permalink" href="#Disabling-BorrowChecker" title="Permalink"></a></h4><p>You can disable BorrowChecker.jl&#39;s functionality by setting <code>borrow_checker = false</code> in your LocalPreferences.toml file (using Preferences.jl). When disabled, all macros like <code>@own</code>, <code>@move</code>, etc., will simply pass through their arguments without any ownership or borrowing checks.</p><p>You can also set the <em>default</em> behavior from within a module (make sure to do this at the very top, before any BorrowChecker calls!)</p><pre><code class="language-julia hljs">module MyModule
    using BorrowChecker: disable_by_default!

    disable_by_default!(@__MODULE__)
    #= Other code =#
end</code></pre><p>This can then be overridden by the LocalPreferences.toml file.</p><p>If you wanted to use BorrowChecker in a library, the idea is you could disable it by default with this command, but enable it during testing, to flag any problematic memory patterns.</p><h3 id="Further-Examples"><a class="docs-heading-anchor" href="#Further-Examples">Further Examples</a><a id="Further-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Examples" title="Permalink"></a></h3><h4 id="Basic-ownership"><a class="docs-heading-anchor" href="#Basic-ownership">Basic ownership</a><a id="Basic-ownership-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-ownership" title="Permalink"></a></h4><p>Let&#39;s look at the basic ownership system. When you create an owned value, it&#39;s immutable by default:</p><pre><code class="language-julia hljs">@own x = [1, 2, 3]
push!(x, 4)  # ERROR: Cannot write to immutable</code></pre><p>For mutable values, use the <code>:mut</code> flag:</p><pre><code class="language-julia hljs">@own :mut data = [1, 2, 3]
push!(data, 4)  # Works! data is mutable</code></pre><p>Note that various functions have been overloaded with the write access settings, such as <code>push!</code>, <code>getindex</code>, etc.</p><p>The <code>@own</code> macro creates an <code>Owned{T}</code> or <code>OwnedMut{T}</code> object. Most functions will not be written to accept these, so you can use <code>@take</code> (copying) or <code>@take!</code> (moving) to extract the owned value:</p><pre><code class="language-julia hljs"># Functions that expect regular Julia types:
push_twice!(x::Vector{Int}) = (push!(x, 4); push!(x, 5); x)

@own x = [1, 2, 3]
@own y = push_twice!(@take!(x))  # Moves ownership of x

push!(x, 4)  # ERROR: Cannot use x: value has been moved</code></pre><p>However, for recursively immutable types (like tuples of integers), <code>@take!</code> is smart enough to know that the original can&#39;t change, and thus it won&#39;t mark a moved:</p><pre><code class="language-julia hljs">@own point = (1, 2)
sum1 = write_to_file(@take!(point))  # point is still usable
sum2 = write_to_file(@take!(point))  # Works again!</code></pre><p>This is the same behavior as in Rust (c.f., the <code>Copy</code> trait).</p><p>There is also the <code>@take(...)</code> macro which never marks the original as moved, and performs a <code>deepcopy</code> when needed:</p><pre><code class="language-julia hljs">@own :mut data = [1, 2, 3]
@own total = sum_vector(@take(data))  # Creates a copy
push!(data, 4)  # Original still usable</code></pre><p>Note also that for improving safety when using BorrowChecker.jl, the macro will actually store the <em>symbol</em> used. This helps catch mistakes like:</p><pre><code class="language-julia hljs">julia&gt; @own x = [1, 2, 3];

julia&gt; y = x;  # Unsafe! Should use @clone, @move, or @own

julia&gt; @take(y)
ERROR: Variable `y` holds an object that was reassigned from `x`.</code></pre><p>This won&#39;t catch all misuses but it can help prevent some.</p><h4 id="Lifetimes"><a class="docs-heading-anchor" href="#Lifetimes">Lifetimes</a><a id="Lifetimes-1"></a><a class="docs-heading-anchor-permalink" href="#Lifetimes" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>References let you temporarily <em>borrow</em> values. This is useful for passing values to functions without moving them. These are created within an explicit <code>@lifetime</code> block:</p><pre><code class="language-julia hljs">@own :mut data = [1, 2, 3]

@lifetime lt begin
    @ref ~lt r = data
    @ref ~lt r2 = data  # Can create multiple _immutable_ references!
    @test r == [1, 2, 3]

    # While ref exists, data can&#39;t be modified:
    data[1] = 4 # ERROR: Cannot write original while immutably borrowed
end

# After lifetime ends, we can modify again!
data[1] = 4</code></pre><p>Just like in Rust, while you can create multiple <em>immutable</em> references, you can only have one <em>mutable</em> reference at a time:</p><pre><code class="language-julia hljs">@own :mut data = [1, 2, 3]

@lifetime lt begin
    @ref ~lt :mut r = data
    @ref ~lt :mut r2 = data  # ERROR: Cannot create mutable reference: value is already mutably borrowed
    @ref ~lt r2 = data  # ERROR: Cannot create immutable reference: value is mutably borrowed

    # Can modify via mutable reference:
    r[1] = 4
end</code></pre><p>When you need to pass immutable references of a value to a function, you would modify the signature to accept a <code>Borrowed{T}</code> type. This is similar to the <code>&amp;T</code> syntax in Rust. And, similarly, <code>BorrowedMut{T}</code> is similar to <code>&amp;mut T</code>.</p><p>Don&#39;t worry about references being used <em>after</em> the lifetime ends, because the <code>lt</code> variable will be expired!</p><pre><code class="language-julia hljs">julia&gt; @own x = 1
       @own :mut cheating = []
       @lifetime lt begin
           @ref ~lt r = x
           push!(cheating, r)
       end
       

julia&gt; @show cheating[1]
ERROR: Cannot use r: value&#39;s lifetime has expired</code></pre><p>This makes the use of references inside threads safe, because the threads <em>must</em> finish inside the scope of the lifetime.</p><p>Though we can&#39;t create multiple mutable references, you <em>are</em> allowed to create multiple mutable references to elements of a collection via the <code>@ref ~lt for</code> syntax:</p><pre><code class="language-julia hljs">@own :mut data = [[1], [2], [3]]

@lifetime lt begin
    @ref ~lt :mut for r in data
        push!(r, 4)
    end
end

@show data  # [[1, 4], [2, 4], [3, 4]]</code></pre><p>&lt;/details&gt;</p><h4 id="Mutating-owned-values"><a class="docs-heading-anchor" href="#Mutating-owned-values">Mutating owned values</a><a id="Mutating-owned-values-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-owned-values" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>Note that if you have a mutable owned value, you can use <code>setproperty!</code> and <code>setindex!</code> as normal:</p><pre><code class="language-julia hljs">mutable struct A
    x::Int
end

@own :mut a = A(0)
for _ in 1:10
    a.x += 1
end
# Move it to an immutable:
@own a_imm = a</code></pre><p>And, as expected:</p><pre><code class="language-julia hljs">julia&gt; a_imm.x += 1
ERROR: Cannot write to immutable

julia&gt; a.x += 1
ERROR: Cannot use a: value has been moved</code></pre><p><strong>You should never mutate via variable reassignment.</strong> If needed, you can repeatedly <code>@own</code> new objects:</p><pre><code class="language-julia hljs">@own x = 1
for _ in 1:10
    @own x = x + 1
end</code></pre><p>&lt;/details&gt;</p><h4 id="Cloning-values"><a class="docs-heading-anchor" href="#Cloning-values">Cloning values</a><a id="Cloning-values-1"></a><a class="docs-heading-anchor-permalink" href="#Cloning-values" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>Sometimes you want to create a completely independent copy of a value. While you could use <code>@own new = @take(old)</code>, the <code>@clone</code> macro provides a clearer way to express this intent:</p><pre><code class="language-julia hljs">@own :mut original = [1, 2, 3]
@clone copy = original  # Creates an immutable deep copy
@clone :mut mut_copy = original  # Creates a mutable deep copy

push!(mut_copy, 4)  # Can modify the mutable copy
@test_throws BorrowRuleError push!(copy, 4)  # Can&#39;t modify the immutable copy
push!(original, 5)  # Original still usable

@test original == [1, 2, 3, 5]
@test copy == [1, 2, 3]
@test mut_copy == [1, 2, 3, 4]</code></pre><p>Another macro is <code>@move</code>, which is a more explicit version of <code>@own new = @take!(old)</code>:</p><pre><code class="language-julia hljs">@own :mut original = [1, 2, 3]
@move new = original  # Creates an immutable deep copy

@test_throws MovedError push!(original, 4)</code></pre><p>Note that <code>@own new = old</code> will also work as a convenience, but <code>@move</code> is more explicit and also asserts that the new value is owned.</p><p>&lt;/details&gt;</p><h4 id="Safe-use-of-closures"><a class="docs-heading-anchor" href="#Safe-use-of-closures">Safe use of closures</a><a id="Safe-use-of-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Safe-use-of-closures" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>Closures in BorrowChecker.jl must follow strict rules because they capture variables from their enclosing scope:</p><pre><code class="language-julia hljs">let
    @own x = 42
    bad_closure = () -&gt; x + 1  # DANGEROUS: captures owned value
end</code></pre><p>The <code>@cc</code> macro validates that closures follow these rules:</p><pre><code class="language-julia hljs">let
    @own x = 42

    # This fails - owned values can&#39;t be captured
    @test_throws ErrorException @cc (a,) -&gt; x + a

    @lifetime lt begin
        @ref ~lt safe_ref = x  # create an immutable reference
        
        # This works - immutable references are safe
        safe_closure = @cc (a,) -&gt; safe_ref + a
    end
    # The reference will expire here, ensuring
    # the closure doesn&#39;t break the borrowing rules!
end</code></pre><p>For threads, you can use the <code>BorrowChecker.@spawn</code> macro instead of the standard <code>Threads.@spawn</code>. This ensures safe captures by automatically applying <code>@cc</code> to the closure (which is generated internally by <code>@spawn</code>):</p><pre><code class="language-julia hljs">@own x = 42
@lifetime lt begin
    @ref ~lt safe_ref = x

    tasks = [
        BorrowChecker.@spawn safe_ref + 1
        for _ in 1:10
    ]
    sum(fetch, tasks)
end</code></pre><p>&lt;/details&gt;</p><h4 id="Automated-Borrowing-with-@bc"><a class="docs-heading-anchor" href="#Automated-Borrowing-with-@bc">Automated Borrowing with <code>@bc</code></a><a id="Automated-Borrowing-with-@bc-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Borrowing-with-@bc" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>The <code>@bc</code> macro simplifies calls involving owned variables. Instead of manually creating <code>@lifetime</code> blocks and references, you just wrap the function call in <code>@bc</code>, which will create a lifetime scope for the duration of the function call, and generate references to owned input arguments. Declare which arguments should be mutable with <code>@mut(...)</code>.</p><pre><code class="language-julia hljs">@own config = Dict(&quot;enabled&quot; =&gt; true)
@own :mut data = [1, 2, 3]

function process(cfg::@&amp;(Dict), arr::@&amp;(:mut, Vector))
    push!(arr, cfg[&quot;enabled&quot;] ? 4 : -1)
    return length(arr)
end

@bc process(config, @mut(data))  # =&gt; 4</code></pre><p>Under the hood, <code>@bc</code> wraps the function call in a <code>@lifetime</code> block, so references end automatically when the call finishes (and thus lose access to the original object).</p><p>This approach works with multiple positional and keyword arguments, and is a convenient way to handle the majority of borrowing patterns. You can freely mix owned, borrowed, and normal Julia values in the same call, and the macro will handle ephemeral references behind the scenes. For cases needing more control or longer lifetimes, manual <code>@lifetime</code> usage is a good option.</p><p>&lt;/details&gt;</p><h4 id="Safe-multi-threading-with-Mutex"><a class="docs-heading-anchor" href="#Safe-multi-threading-with-Mutex">Safe multi-threading with <code>Mutex</code></a><a id="Safe-multi-threading-with-Mutex-1"></a><a class="docs-heading-anchor-permalink" href="#Safe-multi-threading-with-Mutex" title="Permalink"></a></h4><p>&lt;details&gt;</p><p>BorrowChecker provides a <code>Mutex</code> type analogous to Rust&#39;s <code>Mutex</code>, for thread-safe access to shared data, fully integrated with the ownership and borrowing system.</p><pre><code class="language-julia hljs">julia&gt; m = Mutex([1, 2, 3])
       # ^Regular Julia assignment syntax is fine for Mutexes!
Mutex{Vector{Int64}}([1, 2, 3])

julia&gt; lock(m);

julia&gt; @ref_into :mut data = m[]
       # ^Mutable reference to the mutex-protected value
BorrowedMut{Vector{Int64},OwnedMut{Vector{Int64}}}([1, 2, 3], :data)

julia&gt; push!(data, 4);

julia&gt; unlock(m);

julia&gt; m
Mutex{Vector{Int64}}([1, 2, 3, 4])</code></pre><p>The value protected by the mutex is an <code>OwnedMut</code> object, which can therefore be modified.</p><p>Because this value is protected by a spinlock, it is safe to pass around with regular Julia assignment syntax. At any point you wish to read or write to the value, you can use the <code>@ref ~m</code> syntax to create a reference to the value.</p><p>This reference will automatically expire when the lock is released.</p><pre><code class="language-julia hljs">julia&gt; m = Mutex(Dict(&quot;count&quot; =&gt; 0))
Mutex{Dict{String, Int64}}(Dict(&quot;count&quot; =&gt; 0))

julia&gt; @sync for i in 1:100
           Threads.@spawn begin
               lock(m) do
                   @ref_into :mut d = m[]
                   d[&quot;count&quot;] += 1
               end
           end
       end

julia&gt; m
Mutex{Dict{String, Int64}}(Dict(&quot;count&quot; =&gt; 100))

julia&gt; d = lock(m) do
           @ref_into :mut d = m[]
           d
       end;

julia&gt; d[&quot;count&quot;]  # Try to access the value after the lock is released!
ERROR: Cannot use `d`: value&#39;s lifetime has expired</code></pre><p>&lt;/details&gt;</p><h4 id="Introducing-BorrowChecker.jl-to-Your-Codebase"><a class="docs-heading-anchor" href="#Introducing-BorrowChecker.jl-to-Your-Codebase">Introducing BorrowChecker.jl to Your Codebase</a><a id="Introducing-BorrowChecker.jl-to-Your-Codebase-1"></a><a class="docs-heading-anchor-permalink" href="#Introducing-BorrowChecker.jl-to-Your-Codebase" title="Permalink"></a></h4><p>When introducing BorrowChecker.jl to your codebase, the first thing is to <code>@own</code> all variables at the top of a particular function. The simplified version of <code>@own</code> is particularly useful in this case:</p><pre><code class="language-julia hljs">function process_data(x, y, z)
    @own x, y
    @own :mut z

    #= body =#
end</code></pre><p>This pattern is useful for generic functions because if you pass an owned variable as either <code>x</code>, <code>y</code>, or <code>z</code>, the original function will get marked as moved.</p><p>The next pattern that is useful is to use <code>@&amp; T</code> and <code>@&amp; :mut T</code> syntax for extending signatures. This is basically equal to <code>Union{T, Borrowed{T}}</code> and <code>Union{T, BorrowedMut{T}}</code>, respectively (as well as their lazy versions). Let&#39;s say you have some function:</p><pre><code class="language-julia hljs">struct Bar{T}
    x::Vector{T}
end

function foo(bar::Bar{T}) where {T}
    sum(bar.x)
end</code></pre><p>Now, you&#39;d like to modify this so that it can accept <em>references</em> to <code>Bar</code> objects from other functions. Since <code>foo</code> doesn&#39;t need to mutate <code>bar</code>, we can modify this as follows:</p><pre><code class="language-julia hljs">function foo(bar::@&amp;(Bar{T})) where {T}
    sum(bar.x)
end</code></pre><p>Thus, the full <code>process_data</code> function might be something like:</p><pre><code class="language-julia hljs">function process_data(x, y, z)
    @own x, y
    @own :mut z

    @lifetime lt begin
        @ref ~lt r = z
        tasks = [
            BorrowChecker.@spawn(foo(r)),
            BorrowChecker.@spawn(foo(r)),
        ]
        sum(fetch, tasks)
    end
end</code></pre><p>Because we modified <code>foo</code> to accept <code>@&amp; Bar{T}</code>, we can safely pass immutable references to <code>z</code>, and it will <em>not</em> be marked as moved in the original context! Immutable references are safe to pass in a multi-threaded context, so this doubles as a good way to prevent unintended thread races.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="auto/"><code>@auto</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 20 January 2026 01:26">Tuesday 20 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
