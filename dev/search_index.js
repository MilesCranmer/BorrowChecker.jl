var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Ownership-Macros","page":"API Reference","title":"Ownership Macros","text":"","category":"section"},{"location":"api/#References-and-Lifetimes","page":"API Reference","title":"References and Lifetimes","text":"","category":"section"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#IR-Borrow-Checker","page":"API Reference","title":"IR Borrow Checker","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Traits","page":"API Reference","title":"Traits","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"Normally, you should rely on OrBorrowed and OrBorrowedMut to work with borrowed values, or use @take and @take! to unwrap owned values. However, for convenience, it might be useful to define functions on Owned and OwnedMut types, if you are confident that your operation will not \"move\" the input or return a view of it.\n\nMany functions in Base are already overloaded. But if you need to define your own, you can do so by using the request_value function and the AllWrappers type union.","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"AllWrappers{T}: A type union that includes all wrapper types (Owned{T}, OwnedMut{T}, Borrowed{T}, BorrowedMut{T}, and LazyAccessor{T}). This is used to write generic methods that work with any wrapped value.","category":"section"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"request_value(x, Val(:read)): Request read access to a wrapped value\nrequest_value(x, Val(:write)): Request write access to a wrapped value","category":"section"},{"location":"api/#Examples","page":"API Reference","title":"Examples","text":"Here's how common operations are overloaded:\n\nBinary operations (like *) that only need read access:\n\nfunction Base.:(*)(l::AllWrappers{<:Number}, r::AllWrappers{<:Number})\n    return Base.:(*)(request_value(l, Val(:read)), request_value(r, Val(:read)))\nend\n\nMutating operations (like pop!) that need write access:\n\nfunction Base.pop!(r::AllWrappers)\n    return Base.pop!(request_value(r, Val(:write)))\nend\n\nThe request_value function performs safety checks before allowing access:\n\nFor read access: Verifies the value hasn't been moved\nFor write access: Verifies the value is mutable and not borrowed\n\nNote that for operations that need write access, and return a view of the input, it is wise to modify the standard output to return nothing instead, which is what we do for push!:\n\nfunction Base.push!(r::AllWrappers, items...)\n    Base.push!(request_value(r, Val(:write)), items...)\n    return nothing\nend\n\nWhile this violates the expected return type, it is a necessary evil for safety. The nothing return will cause loud errors if you have code that relies on this design. This is good! Loud bugs are collaborators; silent bugs are saboteurs.","category":"section"},{"location":"api/#BorrowChecker.MacrosModule.@own","page":"API Reference","title":"BorrowChecker.MacrosModule.@own","text":"@own [:mut] x = value\n@own [:mut] x, y, z = (value1, value2, value3)\n@own [:mut] for var in iter\n    # body\nend\n@own [:mut] x  # equivalent to @own [:mut] x = x\n@own [:mut] (x, y)  # equivalent to @own [:mut] (x, y) = (x, y)\n\nCreate a new owned variable. If :mut is specified, the value will be mutable. Otherwise, the value will be immutable.\n\nYou may also use @own in a for loop to create an owned value for each iteration.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@move","page":"API Reference","title":"BorrowChecker.MacrosModule.@move","text":"@move [:mut] new = old\n\nTransfer ownership from one variable to another, invalidating the old variable. If :mut is specified, the destination will be mutable. Otherwise, the destination will be immutable. For isbits types, this will automatically use @clone instead.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@clone","page":"API Reference","title":"BorrowChecker.MacrosModule.@clone","text":"@clone [:mut] new = old\n\nCreate a deep copy of a value, without moving the source. If :mut is specified, the destination will be mutable. Otherwise, the destination will be immutable.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@take","page":"API Reference","title":"BorrowChecker.MacrosModule.@take","text":"@take var\n\nReturns the inner value and does a deepcopy. This does not mark the original as moved.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@take!","page":"API Reference","title":"BorrowChecker.MacrosModule.@take!","text":"@take! var\n\nTake ownership of a value, typically used in function arguments. Returns the inner value and marks the original as moved. For isbits types, this will return a copy and not mark the original as moved.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@lifetime","page":"API Reference","title":"BorrowChecker.MacrosModule.@lifetime","text":"@lifetime a begin\n    @ref ~a rx = x\n    # use refs here\nend\n\nCreate a lifetime scope for references. References created with this lifetime are only valid within the block and are automatically cleaned up when the block exits.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@ref","page":"API Reference","title":"BorrowChecker.MacrosModule.@ref","text":"@ref ~lifetime [:mut] var = value\n@ref ~lifetime [:mut] (var1, var2, ...) = (value1, value2, ...)\n@ref ~lifetime [:mut] for var in iter\n    # body\nend\n\nCreate a reference to an owned value within a lifetime scope. See the @lifetime macro for more information on lifetime scopes.\n\nIf :mut is specified, creates a mutable reference. Otherwise, creates an immutable reference. Returns a Borrowed{T} or BorrowedMut{T} that forwards access to the underlying value.\n\nwarning: Warning\nThis will not detect aliasing in the iterator.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MutexModule.Mutex","page":"API Reference","title":"BorrowChecker.MutexModule.Mutex","text":"Mutex{T} <: AbstractMutex{T}\n\nA mutex that protects a value of type T. Provides safe concurrent access to the protected value.\n\nExample\n\nm = Mutex([1, 2, 3])\nlock(m)\n@ref_into :mut arr = m[]\npush!(arr, 4)\nunlock(m)\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.MacrosModule.@ref_into","page":"API Reference","title":"BorrowChecker.MacrosModule.@ref_into","text":"@ref_into [:mut] var = mutex[]\n\nCreate a reference to the protected value in a mutex.\n\nIf :mut is specified, creates a mutable reference. Otherwise, creates an immutable reference.\n\nExamples\n\nm = Mutex([1, 2, 3])\nlock(m) do\n    @ref_into :mut arr2 = m[]\n    push!(arr2, 4)\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@bc","page":"API Reference","title":"BorrowChecker.MacrosModule.@bc","text":"@bc func(args...; kwargs...)\n\nCalls func with the given arguments and keyword arguments, automatically creating temporary borrows for arguments that appear to be owned variables.\n\nExamples\n\nSay that we wish to safely modify an array by reference. We have two owned variables, ar1 and ar2, and we wish to add the first element of ar2 to ar1.\n\n@own :mut ar1 = [1, 2]\n@own ar2 = [3, 4]\n\nadd_first!(x, y) = (x[1] += y[1]; nothing)\n\nIf we set up a lifetime scope manually, we might write:\n\n@lifetime lt begin\n    @ref ~lt :mut ref1 = ar1\n    @ref ~lt ref2 = ar2\n    add_first!(ref1, ref2)\nend\n\nHowever, most of the time you only need to create a lifetime scope for a single function call, so @bc lets us do this automatically:\n\n@bc add_first!(@mut(ar1), ar2)\n\nThis will evaluate to something that is quite similar to the manual lifetime scope.\n\n@bc also supports non-owned variables, which will simply get passed through as-is.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@mut","page":"API Reference","title":"BorrowChecker.MacrosModule.@mut","text":"@mut expr\n\nMarks a value to be borrowed mutably in a @bc macro call.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@&","page":"API Reference","title":"BorrowChecker.MacrosModule.@&","text":"@&(T)\n@&(:mut, T)\n\nType alias macro for borrowed types. @& T expands to Union{T, Borrowed{T}} and @&(:mut, T) expands to Union{T, BorrowedMut{T}} (as well as their LazyAccessor versions).\n\nThis is useful for writing generic signatures that accept either a raw value or a borrowed value.\n\nExamples\n\nHere, we define a function that accepts a mutable borrow of a Vector{Int}. We also demonstrate the use of a Mutex to protect the vector.\n\njulia> function foo(x::@&(:mut, Vector{Int}))\n           push!(x, 4)\n           return nothing\n       end\nfoo (generic function with 1 method)\n\njulia> m = Mutex([1, 2, 3])\nMutex{Vector{Int64}}([1, 2, 3])\n\njulia> lock(m) do\n           @ref_into :mut r = m[]\n           foo(r)\n       end\n\njulia> println(m)\nMutex{Vector{Int64}}([1, 2, 3, 4])\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@cc","page":"API Reference","title":"BorrowChecker.MacrosModule.@cc","text":"@cc closure_expr\n\n\"Closure Check\" is a macro that attempts to verify a closure is compatible with the borrow checker.\n\nOnly immutable references (created with @ref and @bc) are allowed to be captured; all other owned and borrowed variables that are captured will trigger an error.\n\nExamples\n\n@own x = 1\n@own :mut y = 2\n\n@lifetime lt begin\n    @ref ~lt z = x\n    @ref ~lt :mut w = y\n    \n    # These error as the capturing breaks borrowing rules\n    bad = @cc () -> x + 1\n    bad2 = @cc () -> w + 1\n    \n    # However, you are allowed to capture immutable references\n    good = @cc () -> z + 1\n    # This will not error.\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.MacrosModule.@spawn","page":"API Reference","title":"BorrowChecker.MacrosModule.@spawn","text":"BorrowChecker.@spawn [options...] expr\n\nThreads.@spawn but with @cc applied to the expression to ensure safe captures.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.Auto.@auto","page":"API Reference","title":"BorrowChecker.Auto.@auto","text":"Automatically borrow-check a function (best-effort).\n\nBorrowChecker.@auto is a drop-in tripwire for existing code:\n\nAliasing violations: mutating a value while another live binding may observe that mutation.\nEscapes / “moves”: storing a mutable value somewhere that outlives the current scope (e.g. a global cache / a field / a container), then continuing to reference it locally.\n\nOn function entry, it checks the current specialization and caches the result so future calls are fast. On failure it throws BorrowCheckError with best-effort source context.\n\nOptions\n\nOptions are parsed by the macro and compiled into a BorrowChecker.Auto.Config (and are part of the checked-cache key).\n\nscope (default: :function): controls whether the checker recursively borrow-checks callees (call-graph traversal).\n:none: disable @auto entirely (no IR borrow-checking; returns the original definition).\n:function: check only the annotated method.\n:module: recursively check callees whose defining module matches the module where @auto is used.\n:user: recursively check callees, but ignore Core and Base (including their submodules).\n:all: recursively check callees across all modules (very aggressive).\nmax_summary_depth (default: 12): limits recursive effect summarization depth used when the checker cannot directly resolve effects.\n\nExamples:\n\nBorrowChecker.@auto scope=:module function f(x)\n    g(x)\nend\n\nBorrowChecker.@auto max_summary_depth=4 optimize_until=\"compact 1\" function h(x)\n    g(x)\nend\n\nExtended help\n\noptimize_until\n\noptimize_until (default: BorrowChecker.Auto.DEFAULT_CONFIG.optimize_until) controls which compiler pass to stop at when fetching IR via Base.code_ircode_by_type.\n\nPass names vary across Julia versions; @auto tries to normalize common spellings like \"compact 1\" / \"compact_1\" when possible.\n\nwarning: Warning\nThis macro is highly experimental and compiler-dependent. There are likely bugs and false positives. It is intended for development and testing, and does not guarantee memory safety.\n\n\n\n\n\n","category":"macro"},{"location":"api/#BorrowChecker.TypesModule.AbstractOwned","page":"API Reference","title":"BorrowChecker.TypesModule.AbstractOwned","text":"AbstractOwned{T}\n\nBase type for all owned value types.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.AbstractBorrowed","page":"API Reference","title":"BorrowChecker.TypesModule.AbstractBorrowed","text":"AbstractBorrowed{T}\n\nBase type for all borrowed reference types.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.Owned","page":"API Reference","title":"BorrowChecker.TypesModule.Owned","text":"Owned{T} <: AbstractOwned{T}\n\nAn immutable owned value. Common operations:\n\nCreate using @own x = value\nAccess value using @take! (moves) or @take (copies)\nBorrow using @ref\nAccess fields/indices via .field or [indices...] (returns LazyAccessor)\n\nOnce moved, the value cannot be accessed again.\n\nInternal fields (not part of public API):\n\nvalue::T: The contained value\nmoved::Bool: Whether the value has been moved\nimmutable_borrows::Int: Count of active immutable borrows\nsymbol::Symbol: Variable name for error reporting\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.OwnedMut","page":"API Reference","title":"BorrowChecker.TypesModule.OwnedMut","text":"OwnedMut{T} <: AbstractOwned{T}\n\nA mutable owned value. Common operations:\n\nCreate using @own :mut x = value\nAccess value using @take! (moves) or @take (copies)\nModify by setproperty! or setindex!: x.field = value or x[indices...] = value\nBorrow using @ref or @ref :mut\nAccess fields/indices via .field or [indices...] (returns LazyAccessor)\n\nOnce moved, the value cannot be accessed again.\n\nInternal fields (not part of public API):\n\nvalue::T: The contained value\nmoved::Bool: Whether the value has been moved\nimmutable_borrows::Int: Count of active immutable borrows\nmutable_borrows::Int: Count of active mutable borrows\nsymbol::Symbol: Variable name for error reporting\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.Borrowed","page":"API Reference","title":"BorrowChecker.TypesModule.Borrowed","text":"Borrowed{T,O<:AbstractOwned} <: AbstractBorrowed{T}\n\nAn immutable reference to an owned value. Common operations:\n\nCreate using @ref lt x = value\nAccess value using @take (copies)\nAccess fields/indices via .field or [indices...] (returns LazyAccessor)\n\nMultiple immutable references can exist simultaneously. The reference is valid only within its lifetime scope.\n\nInternal fields (not part of public API):\n\nvalue::T: The referenced value\nowner::O: The original owned value\nlifetime::Lifetime: The scope in which this reference is valid\nsymbol::Symbol: Variable name for error reporting\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.BorrowedMut","page":"API Reference","title":"BorrowChecker.TypesModule.BorrowedMut","text":"BorrowedMut{T,O<:OwnedMut} <: AbstractBorrowed{T}\n\nA mutable reference to an owned value. Common operations:\n\nCreate using @ref lt :mut x = value\nAccess value using @take (copies)\nAccess fields/indices via .field or [indices...] (returns LazyAccessor)\n\nOnly one mutable reference can exist at a time, and no immutable references can exist simultaneously.\n\nInternal fields (not part of public API):\n\nvalue::T: The referenced value\nowner::O: The original owned value\nlifetime::Lifetime: The scope in which this reference is valid\nsymbol::Symbol: Variable name for error reporting\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.LazyAccessor","page":"API Reference","title":"BorrowChecker.TypesModule.LazyAccessor","text":"LazyAccessor{T,P,S,O<:Union{AbstractOwned,AbstractBorrowed}} <: AbstractWrapper{T}\n\nA lazy accessor for properties or indices of owned or borrowed values. Maintains ownership semantics while allowing property/index access without copying or moving.\n\nCreated automatically when accessing properties or indices of owned/borrowed values:\n\n@own x = (a=1, b=2)\nx.a  # Returns a LazyAccessor\n\nInternal fields (not part of public API):\n\nparent::P: The parent value being accessed\nproperty::S: The property/index being accessed\nproperty_type::Type{T}: Type of the accessed property/index\ntarget::O: The original owned/borrowed value\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.OrBorrowed","page":"API Reference","title":"BorrowChecker.TypesModule.OrBorrowed","text":"OrBorrowed{T}\n\nType alias for accepting either a value of type T or a borrowed reference to it.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.TypesModule.OrBorrowedMut","page":"API Reference","title":"BorrowChecker.TypesModule.OrBorrowedMut","text":"OrBorrowedMut{T}\n\nType alias for accepting either a value of type T or a mutable borrowed reference to it.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.StaticTraitModule.is_static","page":"API Reference","title":"BorrowChecker.StaticTraitModule.is_static","text":"is_static(x)\n\nThis trait is used to determine if we can safely @take! a value without marking the original as moved.\n\nThis is somewhat analogous to the Copy trait in Rust, although because Julia immutables are truly immutable, we actually do not need to copy on these.\n\nFor the most part, this is equal to isbits, but it also includes things like Symbol and Type{T} (recursively), which are not isbits, but which are immutable.\n\n\n\n\n\n","category":"function"},{"location":"api/#BorrowChecker.ErrorsModule.BorrowError","page":"API Reference","title":"BorrowChecker.ErrorsModule.BorrowError","text":"abstract type BorrowError <: Exception end\n\nBase type for all errors related to borrow checking rules.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.ErrorsModule.MovedError","page":"API Reference","title":"BorrowChecker.ErrorsModule.MovedError","text":"MovedError <: BorrowError\n\nError thrown when attempting to use a value that has been moved.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.ErrorsModule.BorrowRuleError","page":"API Reference","title":"BorrowChecker.ErrorsModule.BorrowRuleError","text":"BorrowRuleError <: BorrowError\n\nError thrown when attempting to violate borrow checking rules, such as having multiple mutable references.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.ErrorsModule.SymbolMismatchError","page":"API Reference","title":"BorrowChecker.ErrorsModule.SymbolMismatchError","text":"SymbolMismatchError <: BorrowError\n\nError thrown when attempting to reassign a variable without using proper ownership transfer mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"api/#BorrowChecker.ErrorsModule.ExpiredError","page":"API Reference","title":"BorrowChecker.ErrorsModule.ExpiredError","text":"ExpiredError <: BorrowError\n\nError thrown when attempting to use a reference whose lifetime has expired.\n\n\n\n\n\n","category":"type"},{"location":"auto/#@auto-(IR-Borrow-Checker)","page":"@auto","title":"@auto (IR Borrow Checker)","text":"@auto is an experimental, compiler-IR-based borrow checker intended as a development tripwire for ordinary Julia code. On function entry it borrow-checks the current specialization and caches the result so subsequent calls are fast. The cache key includes the active @auto options (so e.g. a later call with scope=:module will not be skipped just because scope=:function previously checked the same specialization).\n\nwarning: Warning\n@auto is highly compiler-dependent. Expect false positives and false negatives. It is for testing/debugging, not a safety guarantee.","category":"section"},{"location":"auto/#Basic-Usage","page":"@auto","title":"Basic Usage","text":"using BorrowChecker: @auto\n\n@auto function f(x)\n    y = x\n    x[1] = 0          # may error if `y` can observe this mutation\n    return y\nend\n\nOn failure, @auto throws BorrowChecker.Auto.BorrowCheckError with best-effort source context.","category":"section"},{"location":"auto/#Options","page":"@auto","title":"Options","text":"Options are parsed by the macro and compiled into a BorrowChecker.Auto.Config.","category":"section"},{"location":"auto/#scope","page":"@auto","title":"scope","text":"Controls whether the checker recursively borrow-checks callees (call-graph traversal):\n\nscope=:none: disable @auto entirely (no IR borrow-checking).\nscope=:function (default): check only the annotated method.\nscope=:module: recursively check callees whose defining module matches the module where @auto is used.\nscope=:user: recursively check callees, but ignore Core and Base (including their submodules).\nscope=:all: recursively check callees across all modules (very aggressive; expect more work/edge cases).\n\nnote: Note\nFor scope=:module / scope=:user, callees are filtered by the defining module of the resolved method (so user-defined extensions of Base functions are still treated as “in-module” when appropriate).\n\nExample:\n\n@auto scope=:module function outer(x)\n    return inner(x)\nend","category":"section"},{"location":"auto/#max_summary_depth","page":"@auto","title":"max_summary_depth","text":"Limits recursive effect summarization depth used when the checker cannot directly resolve effects.\n\n@auto max_summary_depth=4 function f(x)\n    return g(x)\nend","category":"section"},{"location":"auto/#optimize_until","page":"@auto","title":"optimize_until","text":"Controls which compiler pass to stop at when fetching IR via Base.code_ircode_by_type.\n\n@auto optimize_until=\"compact 1\" function f(x)\n    return g(x)\nend\n\nPass names vary across Julia versions; @auto normalizes common spellings like \"compact 1\" / \"compact_1\" when possible.","category":"section"},{"location":"auto/#Registry-Overrides-(advanced)","page":"@auto","title":"Registry Overrides (advanced)","text":"The checker uses a small registry of effect specs for non-overloadable primitives. You can add or override specs with:\n\nusing BorrowChecker.Auto: register_effects!","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"section"},{"location":"#BorrowChecker.jl","page":"Home","title":"BorrowChecker.jl","text":"(Image: Dev) (Image: Build Status) (Image: Coverage)\n\nThis is an experimental package for emulating a runtime borrow checker in Julia, using a macro layer over regular code. This is built to mimic Rust's ownership, lifetime, and borrowing semantics. This tool is mainly to be used in development and testing to flag memory safety issues, and help you design safer code.\n\nBorrowChecker.jl currently has two alternative layers:\n\nAutomatic checking (BorrowChecker.@auto)\nDrop-in for existing Julia code: wrap a function and BorrowChecker will run a best-effort borrow check when that method specialization executes.\nIt does not change program behavior (except for throwing when it finds a violation).\nManual overlay (explicit ownership/borrow macros like @own, @ref, @take!, …)\nMore explicit and safer, but much more effort and invasive.\nMore feature complete.\n\nIn Julia, when you write x = [1, 2, 3], the actual object exists completely independently of the variable, and you can refer to it from as many variables as you want without issue:\n\nx = [1, 2, 3]\ny = x\nprintln(length(x))\n# 3\n\nOnce there are no more references to the object, the \"garbage collector\" will work to free the memory.\n\nRust is much different. For example, the equivalent code is invalid in Rust\n\nlet x = vec![1, 2, 3];\nlet y = x;\nprintln!(\"{}\", x.len());\n// error[E0382]: borrow of moved value: `x`\n\nRust refuses to compile this code. Why? Because in Rust, objects (vec![1, 2, 3]) are owned by variables. When you write let y = x, the ownership of vec![1, 2, 3] is moved to y. Now x is no longer allowed to access it.\n\nTo fix this, we would either write\n\nlet y = x.clone();\n// OR\nlet y = &x;\n\nto either create a copy of the vector, or borrow x using the & operator to create a reference. You can create as many references as you want, but there can only be one original object.\n\nThis \"ownership\" paradigm can help improve safety of code. Especially in complex, multithreaded codebases, it is easy to shoot yourself in the foot and modify objects which are \"owned\" (editable) by something else. Rust's ownership and lifetime model makes it so that you can prove memory safety of code! Standard thread races are literally impossible. (Assuming you are not using unsafe { ... } to disable safety features, or the borrow checker itself has a bug, etc.)\n\nIn BorrowChecker.jl, we demonstrate an implementation of some of these ideas. The aim is to build a development layer that can help prevent a few classes of memory safety issues, without affecting runtime behavior of code.","category":"section"},{"location":"#Automatic-Checking:-BorrowChecker.@auto","page":"Home","title":"Automatic Checking: BorrowChecker.@auto","text":"BorrowChecker.@auto automatically instruments a function by analyzing the compiler IR and runs a best-effort borrow check at runtime. This requires Julia ≥ 1.12.\n\n[!WARNING] This macro is highly experimental and compiler-dependent. There are likely bugs and false positives. It is intended for development and testing, and does not guarantee memory safety.","category":"section"},{"location":"#Options","page":"Home","title":"Options","text":"@auto supports a few options that are compiled into a BorrowChecker.Auto.Config:\n\nscope (default :function): whether to recursively borrow-check callees (:none, :function, :module, :user, :all).\nmax_summary_depth (default 12): recursion depth limit for effect summarization when effects cannot be directly resolved.\noptimize_until (default varies): which compiler pass to stop at when fetching IR (Base.code_ircode_by_type).\n\nscope meanings:\n\n:none: disable @auto entirely.\n:function: check only the annotated method.\n:module: recursively check callees defined in the module where @auto is used.\n:user: recursively check callees, but ignore Core and Base (including their submodules).\n:all: recursively check callees across all modules (very aggressive).\n\nThe @auto checked-cache is keyed by specialization and these options, so checking a function once under scope=:function will not incorrectly skip a later recursive check under scope=:module / :all.\n\n@auto is meant to be a drop-in tripwire for existing code:\n\nAliasing violations: mutating a value while another live binding may observe that mutation.\nEscapes / \"moves\": storing a mutable value somewhere that outlives the current scope (e.g. a global cache / a field / a container), then continuing to reference it locally.\n\nThis analyzes the compiler’s IR, so it can catch patterns that are \"hidden\" by lowering (keyword calls, closure captures, views, etc.). It is intentionally best-effort: when it cannot determine what a call does, it will be conservative (and may throw false positives). For code where you want a stronger, explicit model, use the manual overlay macros below.","category":"section"},{"location":"#How-it-works","page":"Home","title":"How it works","text":"When you write:\n\nBorrowChecker.@auto function f(args...)\n    # ...\nend\n\nthe macro rewrites the function so that:\n\nOn entry, it runs a borrow check for the current method specialization (e.g. f(::Vector{Int})), and caches the result (so future calls are faster).\nThe checker asks Julia for the function's typed compiler IR (the lowered form the compiler optimizes).\nIt walks that IR and tracks two key things:\nWhich bindings may refer to the same mutable object (aliasing).\nWhich operations write to a tracked object or cause it to escape (be treated like a move).\nWhen it sees an operation that would be illegal under Rust-like rules (e.g. \"write while aliased\", or \"use after escape\"), it throws a BorrowCheckError with a source-level-ish diagnostic.","category":"section"},{"location":"#Aliasing-Detection","page":"Home","title":"Aliasing Detection","text":"BorrowChecker.jl's @auto macro can detect when values are modified through aliased bindings, and throw an error:\n\njulia> import BorrowChecker\n\njulia> BorrowChecker.@auto function f()\n           x = [1, 2, 3]\n           y = x\n           push!(x, 4)\n           return y\n       end\nf (generic function with 1 method)\n\njulia> f()  # errors\n\nThis will generate a helpful error pointing out the location of the borrow check violation, and the statement that violated the rule:\n\nERROR: BorrowCheckError for specialization Tuple{typeof(f)}\n\n  method: f() @ Main REPL[7]:1\n\n  [1] stmt#7: cannot perform write: value is aliased by another live binding      at REPL[7]:4\n        2         x = [1, 2, 3]\n        3         y = x\n      > 4         push!(x, 4)\n        5         return y\n        6     end\n\n      stmt: Main.push!(%5, 4)\n\n\nTo fix it, simply copy the value, which will avoid the error:\n\njulia> BorrowChecker.@auto function f()\n           x = [1, 2, 3]\n           y = copy(x)\n           push!(x, 4)\n           return y\n       end\nf (generic function with 1 method)\n\njulia> f()\n3-element Vector{Int64}:\n 1\n 2\n 3","category":"section"},{"location":"#Escape-Detection","page":"Home","title":"Escape Detection","text":"Much like Rust's ownership model, BorrowChecker.jl's @auto macro attempts to infer when values escape their scope (moved/consumed) and throw an error if they are used afterwards.\n\njulia> const CACHE = Dict()\nDict{Any, Any}()\n\njulia> foo(x) = (CACHE[x] = 1; nothing)\nfoo (generic function with 1 method)\n\njulia> BorrowChecker.@auto function bar()\n           x = [1, 2]\n           foo(x)\n           return x\n       end\nbar (generic function with 1 method)\n\njulia> bar()  # errors\n\nThis generates the following error:\n\nERROR: BorrowCheckError for specialization Tuple{typeof(bar)}\n\n  method: bar() @ Main REPL[13]:1\n\n  [1] stmt#6: value escapes/consumed by unknown call; it (or an alias) is used later      at REPL[13]:3\n        1     BorrowChecker.@auto function bar()\n        2         x = [1, 2]\n      > 3         foo(x)\n        4         return x\n        5     end\n\n      stmt: Main.foo(%5)\n\nWhy is this an error? Because x was stored as a key in the cache, but is mutable externally. Furthermore, it is returned by bar! This is a violation of borrowing rules. Once the value gets stored in the cache, its ownership is transferred to the cache, and is no longer accessible by bar. So this example is illegal.\n\nHow can we fix it? We have two options. The first is we can copy the value before storing it:\n\njulia> BorrowChecker.@auto function bar()\n           x = [1, 2]\n           foo(copy(x))\n           return x\n       end\nbar (generic function with 1 method)\n\njulia> bar()  # ok\n\nWe no longer have access to the object created by copy(x), so the borrow check passes. Alternatively, we can use immutable objects, which are safe to pass around:\n\njulia> BorrowChecker.@auto function bar()\n           x = (1, 2)\n           foo(x)\n           return x\n       end\nbar (generic function with 1 method)\n\njulia> bar()  # ok","category":"section"},{"location":"#More-@auto-examples","page":"Home","title":"More @auto examples","text":"<details> <summary><code>@auto</code> analyzes the entire callstack</summary>\n\nBorrowChecker doesn't rely on naming conventions, such as the presence of ! in the function name. It tries to infer effects from IR:\n\njulia> h(x) = (push!(x, 1); nothing)  # no \"!\" in the name\nh (generic function with 1 method)\n\njulia> BorrowChecker.@auto function demo()\n           x = [1, 2, 3]\n           y = x\n           h(x)\n           return y\n       end\ndemo (generic function with 1 method)\n\njulia> demo()  # errors\n\n</details>\n\n<details> <summary>Keyword arguments are handled (the checker sees lowered <code>kwcall</code> IR)</summary>\n\nKeyword calls get lowered into a NamedTuple + Core.kwcall(...). @auto analyzes the lowered IR, so aliasing via keyword arguments is still visible:\n\njulia> f(; x, y) = (push!(x, 1); push!(y, 1); x .+ y)\nf (generic function with 1 method)\n\njulia> BorrowChecker.@auto function kw_demo()\n           x = [1, 2, 3]\n           y = x\n           return sum(f(; x=x, y=y))\n       end\nkw_demo (generic function with 1 method)\n\njulia> kw_demo()  # errors\n\n</details>\n\n<details> <summary>Aliasing isn't only <code>y = x</code>: views can alias too</summary>\n\njulia> BorrowChecker.@auto function view_demo()\n           x = [1, 2, 3, 4]\n           y = view(x, 1:2)  # aliases x\n           push!(x, 9)\n           return collect(y)\n       end\nview_demo (generic function with 1 method)\n\njulia> view_demo()  # errors\n\n</details>\n\n<details> <summary>Closures are analyzed too</summary>\n\njulia> BorrowChecker.@auto function closure_demo()\n           x = [1, 2, 3]\n           y = x\n           f = () -> (push!(x, 9); nothing)\n           f()\n           return y\n       end\nclosure_demo (generic function with 1 method)\n\njulia> closure_demo()  # errors\n\nRead-only captures are typically fine. </details>","category":"section"},{"location":"#Manual-Overlay-(explicit-ownership/borrow-macros)","page":"Home","title":"Manual Overlay (explicit ownership/borrow macros)","text":"Alternatively, we can use the manual overlay macros to achieve a more explicit effect. This is much more invasive, but might be useful in teaching you how to think about ownership and borrowing.\n\nThe early Rust example, with BorrowChecker.jl, would look like this:\n\nusing BorrowChecker\n\n@own x = [1, 2, 3]\n@own y = x\nprintln(length(x))\n# ERROR: Cannot use x: value has been moved\n\nYou see, the @own operation has bound the variable x with the object [1, 2, 3]. The second operation then moves the object to y, and flips the .moved flag on x so it can no longer be used by regular operations.\n\nThe equivalent fixes would respectively be:\n\n@clone y = x\n# OR\n@lifetime a begin\n    @ref ~a y = x\n    #= operations on reference =#\nend\n\nNote that BorrowChecker.jl does not prevent you from cheating the system and using y = x (however, the library does try to flag such mistakes by recording symbols used in the macro). To use this library, you will need to buy in to the system to get the most out of it. But the good news is that you can introduce it in a library gradually:  add @own, @move, etc., inside a single function, and call @take! when passing objects to external functions. And for convenience, a variety of standard library functions will automatically forward operations on the underlying objects.","category":"section"},{"location":"#Example:-Preventing-Thread-Races","page":"Home","title":"Example: Preventing Thread Races","text":"BorrowChecker.jl helps prevent data races by enforcing borrowing rules.\n\nLet's mock up a simple scenario where two threads modify the same array concurrently:\n\ndata = [1, 2, 3]\n\nmodify!(x, i) = (sleep(rand()+0.1); push!(x, i))\n\nt1 = Threads.@spawn modify!(data, 4)\nt2 = Threads.@spawn modify!(data, 5)\n\nfetch(t1); fetch(t2)\n\nThis has a silent race condition, and the result will be non-deterministic.\n\nNow, let's see what happens if we had used BorrowChecker:\n\n@own :mut data = [1, 2, 3]\n\nt1 = Threads.@spawn @bc modify!(@mut(data), 4)\nt2 = Threads.@spawn @bc modify!(@mut(data), 5)\n\nNow, when you attempt to fetch the tasks, you will get this error:\n\nnested task error: Cannot create mutable reference: `data` is already mutably borrowed\n\nThis is because in BorrowChecker.jl's ownership model, similar to Rust, an owned object follows strict borrowing rules to prevent data races and ensure safety. (Though, in practice, you should use BorrowChecker.@spawn instead of Threads.@spawn, so that it validates captured variables.)","category":"section"},{"location":"#Ownership-Rules","page":"Home","title":"Ownership Rules","text":"At any given time, an object managed by BorrowChecker.jl can only be accessed in one of the following states:\n\nDirect Ownership:\nThe object is accessed directly via its owning variable.\nNo active references (Borrowed or BorrowedMut) exist.\nIn this state, ownership can be transferred (moved) to another variable, after which the original variable becomes inaccessible. The object can also be mutated if it was declared as mutable (@own :mut ...).\nImmutable Borrows:\nOne or more immutable references (Borrowed) to the object exist.\nWhile any immutable reference is active:\nThe original owning variable cannot be mutated directly.\nOwnership cannot be moved.\nNo mutable references (BorrowedMut) can be created.\nMultiple immutable references can coexist peacefully. This allows multiple parts of the code to read the data concurrently without interference.\nA Mutable Borrow:\nExactly one mutable reference (BorrowedMut) to the object exists.\nWhile the mutable reference is active:\nThe original owning variable cannot be accessed or mutated directly.\nOwnership cannot be moved.\nNo other references (neither immutable Borrowed nor other mutable BorrowedMut) can be created.\nThe object can be mutated through the single active mutable reference. This ensures exclusive write access, preventing data races.\n\nIn essence: You can have many readers (Borrowed) or one writer (BorrowedMut), but not both simultaneously. While any borrow is active, the original owner faces restrictions (cannot be moved, cannot be mutated directly if borrowed immutably, cannot be accessed at all if borrowed mutably).","category":"section"},{"location":"#Sharp-Edges","page":"Home","title":"Sharp Edges","text":"[!CAUTION] Be especially careful with closure functions that capture variables, as this is an easy way to silently break the borrowing rules. You should always use the @cc macro to wrap closures as a form of validation:safe_closure = @cc (x, y) -> x + yThis will validate that any captured variable is an immutable reference. Similarly, you should generally prefer the BorrowChecker.@spawn macro instead of Threads.@spawn to validate captured variables.","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Basics","page":"Home","title":"Basics","text":"@own [:mut] x [= value]: Create a new owned value (mutable if :mut is specified)\nThese are Owned{T} and OwnedMut{T} objects, respectively.\nYou can use @own [:mut] x as a shorthand for @own [:mut] x = x to create owned values at the start of a function.\n@move [:mut] new = old: Transfer ownership from one variable to another (mutable destination if :mut is specified). Note that this is simply a more explicit version of @own for moving values.\n@clone [:mut] new = old: Create a deep copy of a value without moving the source (mutable destination if :mut is specified).\n@take[!] var: Unwrap an owned value. Using @take! will mark the original as moved, while @take will perform a copy.\ngetproperty and getindex on owned/borrowed values return a LazyAccessor that preserves ownership/lifetime until the raw value is used.\nFor example, for an object x::Owned{T}, the accessor x.a would return LazyAccessor{typeof(x.a), T, Val{:a}, Owned{T}} which has the same reading/writing constraints as the original.","category":"section"},{"location":"#References-and-Lifetimes","page":"Home","title":"References and Lifetimes","text":"@lifetime lt begin ... end: Create a scope for references whose lifetimes lt are the duration of the block\n@ref ~lt [:mut] var = value: Create a reference, for the duration of lt, to owned value value and assign it to var (mutable if :mut is specified)\nThese are Borrowed{T} and BorrowedMut{T} objects, respectively. Use these in the signature of any function you wish to make compatible with references. In the signature you can use @&(T) and @&(:mut, T) to also allow regular T.\nMutex(value): Creates a thread-safe container for value. Mutexes manage lifetimes implicitly during locks and do not need @own.\n@ref_into [:mut] var = mutex[]: Create a reference to the value inside a mutex.\nUse lock(m) to acquire the lock, @ref_into to create a reference to the value inside the mutex, and unlock(m) to release the lock.\n@bc f(args...; kws...): This convenience macro automatically creates a lifetime scope for the duration of the function, and sets up borrowing for any owned input arguments.\nUse @mut(arg) to mark an input as mutable.\n@& [:mut] T: Alias for Union{T, Borrowed[Mut]{T}} (incl. lazy versions). Use in function signatures to accept T or its borrowed form.","category":"section"},{"location":"#Validation","page":"Home","title":"Validation","text":"@cc closure_expr: Verifies that closures only capture immutable references.\nBorrowChecker.@spawn [options...] expr: A safety wrapper around Threads.@spawn that applies @cc to the expression (which is internally put inside a closure).","category":"section"},{"location":"#Loops","page":"Home","title":"Loops","text":"@own [:mut] for var in iter: Create a loop over an iterable, assigning ownership of each element to var. The original iter is marked as moved.\n@ref ~lt [:mut] for var in iter: Create a loop over an owned iterable, generating references to each element, for the duration of lt.","category":"section"},{"location":"#Disabling-BorrowChecker","page":"Home","title":"Disabling BorrowChecker","text":"You can disable BorrowChecker.jl's functionality by setting borrow_checker = false in your LocalPreferences.toml file (using Preferences.jl). When disabled, all macros like @own, @move, etc., will simply pass through their arguments without any ownership or borrowing checks.\n\nYou can also set the default behavior from within a module (make sure to do this at the very top, before any BorrowChecker calls!)\n\nmodule MyModule\n    using BorrowChecker: disable_by_default!\n\n    disable_by_default!(@__MODULE__)\n    #= Other code =#\nend\n\nThis can then be overridden by the LocalPreferences.toml file.\n\nIf you wanted to use BorrowChecker in a library, the idea is you could disable it by default with this command, but enable it during testing, to flag any problematic memory patterns.","category":"section"},{"location":"#Further-Examples","page":"Home","title":"Further Examples","text":"","category":"section"},{"location":"#Basic-ownership","page":"Home","title":"Basic ownership","text":"Let's look at the basic ownership system. When you create an owned value, it's immutable by default:\n\n@own x = [1, 2, 3]\npush!(x, 4)  # ERROR: Cannot write to immutable\n\nFor mutable values, use the :mut flag:\n\n@own :mut data = [1, 2, 3]\npush!(data, 4)  # Works! data is mutable\n\nNote that various functions have been overloaded with the write access settings, such as push!, getindex, etc.\n\nThe @own macro creates an Owned{T} or OwnedMut{T} object. Most functions will not be written to accept these, so you can use @take (copying) or @take! (moving) to extract the owned value:\n\n# Functions that expect regular Julia types:\npush_twice!(x::Vector{Int}) = (push!(x, 4); push!(x, 5); x)\n\n@own x = [1, 2, 3]\n@own y = push_twice!(@take!(x))  # Moves ownership of x\n\npush!(x, 4)  # ERROR: Cannot use x: value has been moved\n\nHowever, for recursively immutable types (like tuples of integers), @take! is smart enough to know that the original can't change, and thus it won't mark a moved:\n\n@own point = (1, 2)\nsum1 = write_to_file(@take!(point))  # point is still usable\nsum2 = write_to_file(@take!(point))  # Works again!\n\nThis is the same behavior as in Rust (c.f., the Copy trait).\n\nThere is also the @take(...) macro which never marks the original as moved, and performs a deepcopy when needed:\n\n@own :mut data = [1, 2, 3]\n@own total = sum_vector(@take(data))  # Creates a copy\npush!(data, 4)  # Original still usable\n\nNote also that for improving safety when using BorrowChecker.jl, the macro will actually store the symbol used. This helps catch mistakes like:\n\njulia> @own x = [1, 2, 3];\n\njulia> y = x;  # Unsafe! Should use @clone, @move, or @own\n\njulia> @take(y)\nERROR: Variable `y` holds an object that was reassigned from `x`.\n\nThis won't catch all misuses but it can help prevent some.","category":"section"},{"location":"#Lifetimes","page":"Home","title":"Lifetimes","text":"<details>\n\nReferences let you temporarily borrow values. This is useful for passing values to functions without moving them. These are created within an explicit @lifetime block:\n\n@own :mut data = [1, 2, 3]\n\n@lifetime lt begin\n    @ref ~lt r = data\n    @ref ~lt r2 = data  # Can create multiple _immutable_ references!\n    @test r == [1, 2, 3]\n\n    # While ref exists, data can't be modified:\n    data[1] = 4 # ERROR: Cannot write original while immutably borrowed\nend\n\n# After lifetime ends, we can modify again!\ndata[1] = 4\n\nJust like in Rust, while you can create multiple immutable references, you can only have one mutable reference at a time:\n\n@own :mut data = [1, 2, 3]\n\n@lifetime lt begin\n    @ref ~lt :mut r = data\n    @ref ~lt :mut r2 = data  # ERROR: Cannot create mutable reference: value is already mutably borrowed\n    @ref ~lt r2 = data  # ERROR: Cannot create immutable reference: value is mutably borrowed\n\n    # Can modify via mutable reference:\n    r[1] = 4\nend\n\nWhen you need to pass immutable references of a value to a function, you would modify the signature to accept a Borrowed{T} type. This is similar to the &T syntax in Rust. And, similarly, BorrowedMut{T} is similar to &mut T.\n\nDon't worry about references being used after the lifetime ends, because the lt variable will be expired!\n\njulia> @own x = 1\n       @own :mut cheating = []\n       @lifetime lt begin\n           @ref ~lt r = x\n           push!(cheating, r)\n       end\n       \n\njulia> @show cheating[1]\nERROR: Cannot use r: value's lifetime has expired\n\nThis makes the use of references inside threads safe, because the threads must finish inside the scope of the lifetime.\n\nThough we can't create multiple mutable references, you are allowed to create multiple mutable references to elements of a collection via the @ref ~lt for syntax:\n\n@own :mut data = [[1], [2], [3]]\n\n@lifetime lt begin\n    @ref ~lt :mut for r in data\n        push!(r, 4)\n    end\nend\n\n@show data  # [[1, 4], [2, 4], [3, 4]]\n\n</details>","category":"section"},{"location":"#Mutating-owned-values","page":"Home","title":"Mutating owned values","text":"<details>\n\nNote that if you have a mutable owned value, you can use setproperty! and setindex! as normal:\n\nmutable struct A\n    x::Int\nend\n\n@own :mut a = A(0)\nfor _ in 1:10\n    a.x += 1\nend\n# Move it to an immutable:\n@own a_imm = a\n\nAnd, as expected:\n\njulia> a_imm.x += 1\nERROR: Cannot write to immutable\n\njulia> a.x += 1\nERROR: Cannot use a: value has been moved\n\nYou should never mutate via variable reassignment. If needed, you can repeatedly @own new objects:\n\n@own x = 1\nfor _ in 1:10\n    @own x = x + 1\nend\n\n</details>","category":"section"},{"location":"#Cloning-values","page":"Home","title":"Cloning values","text":"<details>\n\nSometimes you want to create a completely independent copy of a value. While you could use @own new = @take(old), the @clone macro provides a clearer way to express this intent:\n\n@own :mut original = [1, 2, 3]\n@clone copy = original  # Creates an immutable deep copy\n@clone :mut mut_copy = original  # Creates a mutable deep copy\n\npush!(mut_copy, 4)  # Can modify the mutable copy\n@test_throws BorrowRuleError push!(copy, 4)  # Can't modify the immutable copy\npush!(original, 5)  # Original still usable\n\n@test original == [1, 2, 3, 5]\n@test copy == [1, 2, 3]\n@test mut_copy == [1, 2, 3, 4]\n\nAnother macro is @move, which is a more explicit version of @own new = @take!(old):\n\n@own :mut original = [1, 2, 3]\n@move new = original  # Creates an immutable deep copy\n\n@test_throws MovedError push!(original, 4)\n\nNote that @own new = old will also work as a convenience, but @move is more explicit and also asserts that the new value is owned.\n\n</details>","category":"section"},{"location":"#Safe-use-of-closures","page":"Home","title":"Safe use of closures","text":"<details>\n\nClosures in BorrowChecker.jl must follow strict rules because they capture variables from their enclosing scope:\n\nlet\n    @own x = 42\n    bad_closure = () -> x + 1  # DANGEROUS: captures owned value\nend\n\nThe @cc macro validates that closures follow these rules:\n\nlet\n    @own x = 42\n\n    # This fails - owned values can't be captured\n    @test_throws ErrorException @cc (a,) -> x + a\n\n    @lifetime lt begin\n        @ref ~lt safe_ref = x  # create an immutable reference\n        \n        # This works - immutable references are safe\n        safe_closure = @cc (a,) -> safe_ref + a\n    end\n    # The reference will expire here, ensuring\n    # the closure doesn't break the borrowing rules!\nend\n\nFor threads, you can use the BorrowChecker.@spawn macro instead of the standard Threads.@spawn. This ensures safe captures by automatically applying @cc to the closure (which is generated internally by @spawn):\n\n@own x = 42\n@lifetime lt begin\n    @ref ~lt safe_ref = x\n\n    tasks = [\n        BorrowChecker.@spawn safe_ref + 1\n        for _ in 1:10\n    ]\n    sum(fetch, tasks)\nend\n\n</details>","category":"section"},{"location":"#Automated-Borrowing-with-@bc","page":"Home","title":"Automated Borrowing with @bc","text":"<details>\n\nThe @bc macro simplifies calls involving owned variables. Instead of manually creating @lifetime blocks and references, you just wrap the function call in @bc, which will create a lifetime scope for the duration of the function call, and generate references to owned input arguments. Declare which arguments should be mutable with @mut(...).\n\n@own config = Dict(\"enabled\" => true)\n@own :mut data = [1, 2, 3]\n\nfunction process(cfg::@&(Dict), arr::@&(:mut, Vector))\n    push!(arr, cfg[\"enabled\"] ? 4 : -1)\n    return length(arr)\nend\n\n@bc process(config, @mut(data))  # => 4\n\nUnder the hood, @bc wraps the function call in a @lifetime block, so references end automatically when the call finishes (and thus lose access to the original object).\n\nThis approach works with multiple positional and keyword arguments, and is a convenient way to handle the majority of borrowing patterns. You can freely mix owned, borrowed, and normal Julia values in the same call, and the macro will handle ephemeral references behind the scenes. For cases needing more control or longer lifetimes, manual @lifetime usage is a good option.\n\n</details>","category":"section"},{"location":"#Safe-multi-threading-with-Mutex","page":"Home","title":"Safe multi-threading with Mutex","text":"<details>\n\nBorrowChecker provides a Mutex type analogous to Rust's Mutex, for thread-safe access to shared data, fully integrated with the ownership and borrowing system.\n\njulia> m = Mutex([1, 2, 3])\n       # ^Regular Julia assignment syntax is fine for Mutexes!\nMutex{Vector{Int64}}([1, 2, 3])\n\njulia> lock(m);\n\njulia> @ref_into :mut data = m[]\n       # ^Mutable reference to the mutex-protected value\nBorrowedMut{Vector{Int64},OwnedMut{Vector{Int64}}}([1, 2, 3], :data)\n\njulia> push!(data, 4);\n\njulia> unlock(m);\n\njulia> m\nMutex{Vector{Int64}}([1, 2, 3, 4])\n\nThe value protected by the mutex is an OwnedMut object, which can therefore be modified.\n\nBecause this value is protected by a spinlock, it is safe to pass around with regular Julia assignment syntax. At any point you wish to read or write to the value, you can use the @ref ~m syntax to create a reference to the value.\n\nThis reference will automatically expire when the lock is released.\n\njulia> m = Mutex(Dict(\"count\" => 0))\nMutex{Dict{String, Int64}}(Dict(\"count\" => 0))\n\njulia> @sync for i in 1:100\n           Threads.@spawn begin\n               lock(m) do\n                   @ref_into :mut d = m[]\n                   d[\"count\"] += 1\n               end\n           end\n       end\n\njulia> m\nMutex{Dict{String, Int64}}(Dict(\"count\" => 100))\n\njulia> d = lock(m) do\n           @ref_into :mut d = m[]\n           d\n       end;\n\njulia> d[\"count\"]  # Try to access the value after the lock is released!\nERROR: Cannot use `d`: value's lifetime has expired\n\n</details>","category":"section"},{"location":"#Introducing-BorrowChecker.jl-to-Your-Codebase","page":"Home","title":"Introducing BorrowChecker.jl to Your Codebase","text":"When introducing BorrowChecker.jl to your codebase, the first thing is to @own all variables at the top of a particular function. The simplified version of @own is particularly useful in this case:\n\nfunction process_data(x, y, z)\n    @own x, y\n    @own :mut z\n\n    #= body =#\nend\n\nThis pattern is useful for generic functions because if you pass an owned variable as either x, y, or z, the original function will get marked as moved.\n\nThe next pattern that is useful is to use @& T and @& :mut T syntax for extending signatures. This is basically equal to Union{T, Borrowed{T}} and Union{T, BorrowedMut{T}}, respectively (as well as their lazy versions). Let's say you have some function:\n\nstruct Bar{T}\n    x::Vector{T}\nend\n\nfunction foo(bar::Bar{T}) where {T}\n    sum(bar.x)\nend\n\nNow, you'd like to modify this so that it can accept references to Bar objects from other functions. Since foo doesn't need to mutate bar, we can modify this as follows:\n\nfunction foo(bar::@&(Bar{T})) where {T}\n    sum(bar.x)\nend\n\nThus, the full process_data function might be something like:\n\nfunction process_data(x, y, z)\n    @own x, y\n    @own :mut z\n\n    @lifetime lt begin\n        @ref ~lt r = z\n        tasks = [\n            BorrowChecker.@spawn(foo(r)),\n            BorrowChecker.@spawn(foo(r)),\n        ]\n        sum(fetch, tasks)\n    end\nend\n\nBecause we modified foo to accept @& Bar{T}, we can safely pass immutable references to z, and it will not be marked as moved in the original context! Immutable references are safe to pass in a multi-threaded context, so this doubles as a good way to prevent unintended thread races.","category":"section"}]
}
